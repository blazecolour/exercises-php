---

name: else if
theory: |

  Функция `getTypeOfSentence`, описанная в предыдущем уроке, учитывает только вопросительные предложения. Используя полученные знания, несложно расширить ее поведение для поддержки и восклицательных:

  ```php
  <?php

  function getTypeOfSentence($sentence)
  {
      $lastChar = substr($sentence, -1);
      if ($lastChar === '?') {
          $sentenceType = 'question';
      }

      if ($lastChar === '!') {
          $sentenceType = 'shouting';
      } else {
          $sentenceType = 'normal';
      }

      return "Sentence is {$sentenceType}";
  }
  ```

  Все сводится к добавлению еще одной проверки и чисто технически функция работает исправно. А вот с точки зрения семантики, есть определенные проблемы. Почему ветка `else` описана именно для второго ифа, а не для первого? К тому же в нашем примере, ветвление взаимоисключающее. Оно таким и является, но только за счет самих предикатов, а вот структура ифов говорит о том что, в теории, выполнение кода может зайти в каждую из веток в рамках одного вызова.

  Для устранения семантического разрыва правильно воспользоваться еще одним способом записи конструкции `if`:

  ```php
  <?php

  function getTypeOfSentence($sentence)
  {
      $lastChar = substr($sentence, -1);
      if ($lastChar === '?') {
          $sentenceType = 'question';
      } elseif ($lastChar === '!') {
          $sentenceType = 'question';
      } else {
          $sentenceType = 'normal';
      }

      return "Sentence is {$sentenceType}";
  }
  ```

  Основное отличие от предыдущего способа в том, что условия выстраиваются в единую, связанную конструкцию. Связующим звеном служит ключевое слов `elseif` после которого идет блок кода. В этом коде, безотносительно реализации предикатов, выполниться может лишь один из блоков кода относящихся ко всей конструкции `if`. Обратите внимание на то что ветка `else` - опциональна.

instructions: |

  На электронной карте Вестероса, которую реализовал Сэм, союзники Старков отображены зеленым кружком, враги, красным, а те кто занимает нейтральную позицию - серым. Помогите Сэму реализовать функцию `whoIsThisHouseForStarks`, которая принимает на вход имя дома и возвращает одно из трех значений _friend_, _enemy_, _neutral_. Правила определения следующие:

    * Друзья: 'karstark', 'tally'
    * Враги: 'lannister', 'frey'
    * Все остальные считаются нейтральными (в рамках работы этой функции)

tips: []
