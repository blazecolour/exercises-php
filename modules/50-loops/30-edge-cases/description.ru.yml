---

name: Пограничные случаи
theory: |

  Функция `mysubstr`, которую вы реализовали в прошлом уроке, содержит множество ошибок. Но ведь она прошла проверки скажете вы? Да, но в этих проверках не было так называемых "пограничных случаев". Как поведет себя ваша функция, если передать ей следующие варианты длин:

  * `0`
  * Отрицательную длину
  * Длину превышающую реальный размер строки

  Ошибки в пограничных случаях - самая частая причина логических ошибок в программах. Программисты всегда забывают что-нибудь учесть. Самое неприятное, то что такие ошибки, нередко проявляются не сразу и часто не приводят к видимым ошибкам. Программа продолжает работать, но через какое-то время обнаруживается что данные неверны (привет слабой типизации в php). Умение работать с такими типами ошибок приходит с опытом, через постоянные косяки в стиле "ой забыл проверить на пустоту".

  Давайте расширим функцию `mysubstr` из прошлого урока, до ее полной версии. Пусть она принимает на вход три параметра: строчку, начальный индекс и длину. Прикинем что может пойти не так:

  * Отрицательный индекс
  * Положительный индекс, но выходящий за границу строки
  * Длина подстроки, которая в сумме с начальным индексом приводит к выходу за границу
  * Отрицательная длина строки

  С точки зрения реализации функции, каждый пограничный случай фактически отдельный кусок кода (вероятно `if`). Поэтому они и называются пограничными, так как требуют особую обработку.

instructions: |

  Реализуйте функцию (предикат) `isArgumentsForSubstrCorrect`, которая принимает на вход тоже что и `substr`, но возвращает `true` в случае если аргументы корректные и `false` если нет. Корректность определяется пограничными случаями. Если подстроку нельзя изъять из-за нарушений (например выход за границу), то возвращается `false` иначе `true`.

  Пример вызова:

  ```php
  <?php

  $str = 'Sansa Stark';
  isArgumentsForSubstrCorrect($str, -1, 3); // => false
  isArgumentsForSubstrCorrect($str, 4, 100); // => false
  isArgumentsForSubstrCorrect($str, 10, 10); // => false
  isArgumentsForSubstrCorrect($str, 11, 1); // => false
  isArgumentsForSubstrCorrect($str, 3, 3); // => true
  ```
  ```

tips: []
