---

name: Функции как аргументы функций
theory: |

  Продолжаем тему выражений. Как вы помните, вызов функции - выражение, а значит мы можем положить функцию в функцию пока мы используем функцию. Предположим что нам нужно сначала получить модуль числа, а затем округлить его до одного знака после запятой. С новыми знаниями на руках, мы можем написать следующий код:

  ```php
  <?php

  $number = 100.234203;
  $result = round(abs($number), 2);
  ```

  Выше вызывается функция `round` в которую передается результат вызова функции `abs` с аргументом `$number` и двойка.

  Тоже самое можно выполнить и в несколько отдельных этапов:

  ```php
  <?php

  $number = 100.234203;
  $module = abs($number);
  $result = round($module, 2);
  ```

  Тогда возникает вопрос, какой вариант предпочтительнее? Если вычисление совсем простое и не глубокое (не больше одного вложения функции), то можно смело вкладывать. В остальных ситуациях предпочтительно разбивать вызовы на промежуточные вычисления. Причины все те же. Чтение такого кода значительно легче, во-первых из-за промежуточных переменных, которые своим названием отражают суть операций, во-вторых такой код легче отлаживать и исследовать промежуточные данные и в-третьих глубокие вложенные вызовы читать мягко говоря не просто. В продвинутых языках подобная проблема решается механизмом типа композиции функций, но в PHP, к сожалению, подобного нет, поэтому только так.

  В остальном вы уже знаете. Внутрь вызова функции, которая вложена в другой вызов, можно передать аргументами снова функции! И так далее до бесконечности. Такое свойство системы называется рекурсией. Код повторяет сам себя. Внутри каждого вызова маленькая программа, внутри которой тоже программа, внутри которой тоже программа... Помните, у попа была собака? Это оно.

  Давайте еще раз взгянем на код и попробуем ответить на вопрос, в каком порядке что будет вычисляться?

  ```php
  <?php

  $number = -100.234203;
  $result = round(abs($number), round(2.43));
  ```

  PHP, как и большинство других традиционных языков, является языком с жадными вычислениями (противопоставляются ленивым). То есть он пытается вычислить сначала максимально глубокий уровень вызова и идет снизу вверх. В примере выше, сначала будет вычислены аргументы, и затем, уже готовые данные, попадут в вызов `round`. Ситуация с вложенными вызовами функций часто вводят новичков в ступор. В этом аспекте никакой магии, нужно просто чуть больше тренировок.

  Разложим работу кода выше по шагам:

    1. `round(abs(-100.234203), round(2.43));`
    1. `round(100.234203, round(2.43));`
    1. `round(100.234203, 2);`
    1. `100.23`



instructions: |

  Для построения геологического древа семьи Старков, Сэм реализовал функцию `parentFor`, которая возвращает имя родителя если передать ему имя ребенка. Вторым параметром функция принимает на вход строчку `father` или `mother`. С помощью нее она понимает кого возвращать из родителей. По умолчанию параметр равен `mother`.

  Реализуйте программу, которая печатает на экран имя деда Джоффри по материнской линии.

tips: []
